import java.util.StringTokenizer;
import java.util.Vector;

/**
 * Encapsulates a move
 *
 * In general, you should regard this as an opaque structure that exists in the
 * GameState you obtain from FindPossibleMoves.
 *
 * The functions IsNormal(), IsJump() and IsEOG(), might be useful.
 *
 * You can probably ignore the rest of the class interface.
 */
public class Move {
    static final String cDelimiter = "_";

    private int mType;
    private Vector<Integer> mData = new Vector<Integer>();

    /**
     * constructs a special type move
     *
     * @param moveType
     *            moveType should be one of MOVE_BOG, MOVE_RW, MOVE_WW or MOVE_DRAW
     * @return
     */
    public Move(int moveType) {
        this.mType = moveType;
    }

    /**
     * Constructs a MOVE_BOG move.
     */
    public Move() {
        this(MOVE_BOG);
    }

    /**
     * constructs a normal move (not a jump)
     *
     * @param p1
     *            the source square
     * @param p2
     *            the destination square
     */
    public Move(int p1, int p2) {
        this(MOVE_NORMAL);

        assert (this.mData.size() == 0);

        this.mData.add(p1);
        this.mData.add(p2);
    }

    /**
     * Constructs a jump move
     *
     * @param pData
     *            a series of squares that form the sequence of jumps
     */
    public Move(Vector<Integer> pData, int len) {
        this.mType = len - 1;
        this.mData.setSize(0);
        for (int i = 0; i < len; i++) {
            this.mData.add(pData.get(i));
        }
    }

    /**
     * reconstructs the move from a string
     *
     * @param \param pString a string, which should have been previously
     *        generated by ToMessage(), or obtained from the server.
     */
    public Move(final String pString) {
        StringTokenizer st = new StringTokenizer(pString, Move.cDelimiter);
        String str = st.nextToken();

        this.mType = Integer.parseInt(str);

        int lLen = 0;

        if (mType == MOVE_NORMAL) {
            lLen = 2;
        } else if (mType > 0) {
            lLen = mType + 1;
        }

        if (lLen > 12 || mType < MOVE_NULL) {
            mType = MOVE_NULL;
            return;
        }

        this.mData.setSize(lLen);

        for (int i = 0; i < lLen; i++) {
            int lCell;

            str = st.nextToken();
            lCell = Integer.parseInt(str);

            if (lCell < 1 || lCell > 32) {
                this.mType = MOVE_NULL;
                break;
            }

            this.mData.set(i, lCell);
        }

        if (st.hasMoreTokens()) {
            this.mType = MOVE_NULL;
        }
    }

    /**
     * Create a deep copy
     */
    public Move(Move m) {
        this.mType = m.mType;
        this.mData = new Vector<Integer>(m.mData);
    }

    /**
     * @return A reverse version of this move
     */
    public Move reversed() {
        Move result = new Move(this);

        if (this.isRedWin()) {
            result.mType = MOVE_WW;
        } else if (this.isWhiteWin()) {
            result.mType = MOVE_RW;
        }

        for (int i = 0; i < this.mData.size(); i++) {
            result.mData.set(i, 33 - this.mData.elementAt(i));
        }
        return result;
    }

    /**
     * @return true if the movement is null or invalid
     */
    public boolean isNull() {
        return (this.mType == MOVE_NULL);
    }

    /**
     * @return true if the movement marks beginning of game
     */
    public boolean isBOG() {
        return (this.mType == MOVE_BOG);
    }

    /**
     * @return true if the movement marks end of game
     */
    public boolean isEOG() {
        return (this.mType < MOVE_BOG);
    }

    /**
     * @return true if the game ended in red win
     */
    public boolean isRedWin() {
        return (this.mType == MOVE_RW);
    }

    /**
     * @return true if the game ended in white win
     */
    public boolean isWhiteWin() {
        return (this.mType == MOVE_WW);
    }

    /**
     * @return true if the game ended in draw
     */
    public boolean isDraw() {
        return (this.mType == MOVE_DRAW);
    }

    /**
     * @return true if the movement is a jump
     */
    public boolean isJump() {
        return (this.mType > 0);
    }

    /**
     * @returns true if the movement is a normal move
     */
    public boolean isNormal() {
        return (this.mType == MOVE_NORMAL);
    }

    /**
     * @returns the type of the move
     */
    public int getType() {
        return this.mType;
    }

    /**
     * @return (for normal moves and jumps) the number of squares
     */
    public int length() {
        return this.mData.size();
    }

    /**
     * @return the pN-th square in the sequence
     */
    public int at(int pN) {
        return this.mData.elementAt(pN);
    }

    /**
     * converts the move to a string so that it can be sent to the other player
     */
    public String toMessage() {
        String lStream = new String();
        lStream = lStream + mType;

        for (int i = 0; i < this.mData.size(); i++) {
            lStream = lStream + cDelimiter + this.mData.elementAt(i);
        }

        return lStream;
    }

    /**
     * converts the move to a human readable string so that it can be printed
     */
    public String toString() {
        if (this.mType == MOVE_WW) {
            return "WW";
        }
        if (this.mType == MOVE_RW) {
            return "RW";
        }
        if (this.mType == MOVE_DRAW) {
            return "DRAW";
        }
        if (this.mType == MOVE_BOG) {
            return "BOG";
        }
        if (this.isNull()) {
            return "NULL";
        }

        String lStream = new String();
        String delimiter = isNormal() ? "-" : "x";

        assert (this.mData.size() > 0);

        // Concatenate all the cell numbers
        lStream = lStream + this.mData.elementAt(0);

        for (int i = 1; i < this.mData.size(); i++) {
            lStream = lStream + delimiter + this.mData.elementAt(i);
        }

        return lStream;
    }

    /**
     * @return true if the two objects represent the same move
     */
    public boolean equals(final Move pRH) {
        if (this.mType != pRH.mType) {
            return false;
        }

        if (this.mData.size() != pRH.mData.size()) {
            return false;
        }

        for (int i = 0; i < this.mData.size(); i++) {
            if (this.mData.elementAt(i) != pRH.mData.elementAt(i)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Constants for type of moves.
     *
     */
    public static final int MOVE_JUMP   = 1;  // / a single jump (numbers above that will represent multiple jumps)
    public static final int MOVE_NORMAL = 0;  // / a normal move
    public static final int MOVE_BOG    = -1; // / beginning of game
    public static final int MOVE_RW     = -2; // / red wins => end of game
    public static final int MOVE_WW     = -3; // / white wins => end of game
    public static final int MOVE_DRAW   = -4; // / draw => end of game
    public static final int MOVE_NULL   = -5; // / a null move
}
